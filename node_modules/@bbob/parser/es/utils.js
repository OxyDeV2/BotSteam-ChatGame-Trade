import { QUOTEMARK, BACKSLASH } from '@bbob/plugin-helper/lib/char';

/**
 * @typedef {Object} CharGrabber
 * @property {Function} skip
 * @property {Function} hasNext
 * @property {Function} isLast
 * @property {Function} grabWhile
 */

/**
 * Creates a grabber wrapper for source string, that helps to iterate over string char by char
 * @param {String} source
 * @param {Function} onSkip
 * @returns
 */
export var createCharGrabber = function createCharGrabber(source) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      onSkip = _ref.onSkip;

  var idx = 0;

  var skip = function skip() {
    idx += 1;

    if (onSkip) {
      onSkip();
    }
  };
  var hasNext = function hasNext() {
    return source.length > idx;
  };
  var getRest = function getRest() {
    return source.substr(idx);
  };
  var getCurr = function getCurr() {
    return source[idx];
  };

  return {
    skip: skip,
    hasNext: hasNext,
    isLast: function isLast() {
      return idx === source.length;
    },
    grabWhile: function grabWhile(cond) {
      var start = idx;

      while (hasNext() && cond(getCurr())) {
        skip();
      }

      return source.substr(start, idx - start);
    },
    getNext: function getNext() {
      return source[idx + 1];
    },
    getPrev: function getPrev() {
      return source[idx - 1];
    },
    getCurr: getCurr,
    getRest: getRest,
    /**
     * Grabs rest of string until it find a char
     * @param {String} char
     * @return {String}
     */
    substrUntilChar: function substrUntilChar(char) {
      var restStr = getRest();
      var indexOfChar = restStr.indexOf(char);

      if (indexOfChar >= 0) {
        return restStr.substr(0, indexOfChar);
      }

      return '';
    }
  };
};

/**
 * Trims string from start and end by char
 * @example
 *  trimChar('*hello*', '*') ==> 'hello'
 * @param {String} str
 * @param {String} charToRemove
 * @returns {String}
 */
export var trimChar = function trimChar(str, charToRemove) {
  while (str.charAt(0) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(1);
  }

  while (str.charAt(str.length - 1) === charToRemove) {
    // eslint-disable-next-line no-param-reassign
    str = str.substring(0, str.length - 1);
  }

  return str;
};

/**
 * Unquotes \" to "
 * @param str
 * @return {String}
 */
export var unquote = function unquote(str) {
  return str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);
};

/**
 * @typedef {Object} ItemList
 * @type {Object}
 * @property {getLastCb} getLast
 * @property {flushLastCb} flushLast
 * @property {pushCb} push
 * @property {toArrayCb} toArray
 */

/**
 *
 * @param values
 * @return {ItemList}
 */
export var createList = function createList() {
  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var nodes = values;
  /**
   * @callback getLastCb
   */
  var getLast = function getLast() {
    return nodes.length ? nodes[nodes.length - 1] : null;
  };
  /**
   * @callback flushLastCb
   * @return {*}
   */
  var flushLast = function flushLast() {
    if (nodes.length) {
      return nodes.pop();
    }

    return false;
  };
  /**
   * @callback pushCb
   * @param value
   */
  var push = function push(value) {
    return nodes.push(value);
  };

  /**
   * @callback toArrayCb
   * @return {Array}
   */

  return {
    getLast: getLast,
    flushLast: flushLast,
    push: push,
    toArray: function toArray() {
      return nodes;
    }
  };
};